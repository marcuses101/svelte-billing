generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = "postgresql://marcus:password@localhost:5432/svelte-billing"
}

// Define the Skater table
model Skater {
    id                String              @id @default(uuid())
    firstName         String
    lastName          String
    email             String
    dateOfBirth       DateTime?
    createdOn         DateTime            @default(now())
    modifiedOn        DateTime?
    lessons           SkaterLesson[]
    invoices          Invoice[]
    Account           Account             @relation(fields: [accountId], references: [id])
    accountId         String              @unique
    AdditionalCharges AdditionalCharges[]

    @@unique([firstName, lastName])
}

model Role {
    name     String     @id @unique
    UserRole UserRole[]
}

// Define the User table
model User {
    id        String     @id @default(uuid())
    email     String     @unique
    firstName String?
    lastName  String?
    UserRoles UserRole[]
    Coach     Coach?
}

model UserRole {
    user     User   @relation(fields: [userId], references: [id])
    userId   String
    Role     Role   @relation(fields: [roleName], references: [name])
    roleName String

    @@id([userId, roleName])
}

model Coach {
    id                   String         @id @default(uuid())
    hourlyRateInCents    Int
    commissionPercentage Int
    user                 User           @relation(fields: [userId], references: [id])
    userId               String         @unique
    lessons              Lesson[]
    CoachPayrollRecords  CoachPaySlip[]
    Account              Account        @relation(fields: [accountId], references: [id])
    accountId            String         @unique
}

model Lesson {
    id                         String    @id @default(uuid())
    lessonTimeInMinutes        Int
    lessonCostInCents          Int
    lessonCostPerSkaterInCents Int
    date                       DateTime
    createdOn                  DateTime  @default(now())
    modifiedOn                 DateTime?

    coachId String

    Coach                Coach                 @relation(fields: [coachId], references: [id])
    SkaterLessons        SkaterLesson[]
    CoachPaySlipLineItem CoachPaySlipLineItem?
}

// used for additional charges such as competition fees
model AdditionalCharges {
    id            String   @id @default(uuid())
    description   String
    amountInCents Int
    date          DateTime @db.Date
    Skater        Skater   @relation(fields: [skaterId], references: [id])
    skaterId      String
}

model Invoice {
    id          String    @id @default(uuid())
    invoiceDate DateTime  @db.Date
    Skater      Skater    @relation(fields: [skaterId], references: [id])
    skaterId    String
    createdOn   DateTime  @default(now())
    modifiedOn  DateTime?

    invoiceBatchId String?

    BillingBatch     BillingBatch?      @relation(fields: [invoiceBatchId], references: [id])
    InvoiceLineItems InvoiceLineItems[]
}

model InvoiceLineItems {
    id            String   @id @default(uuid())
    description   String
    amountInCents Int
    date          DateTime @db.Date

    invoiceId            String
    skaterLessonSkaterId String?
    skaterLessonLessonId String?

    SkaterLesson SkaterLesson? @relation(fields: [skaterLessonSkaterId, skaterLessonLessonId], references: [skaterId, lessonId])
    Invoice      Invoice       @relation(fields: [invoiceId], references: [id])
}

model CoachPaySlip {
    id      String @id @default(uuid())
    Coach   Coach  @relation(fields: [coachId], references: [id])
    coachId String

    CoachPayrollLineItems CoachPaySlipLineItem[]
}

model CoachPaySlipLineItem {
    id                   String   @id @default(uuid())
    description          String
    amountInCents        Int
    date                 DateTime @db.Date
    coachPayrollRecordId String

    lessonId String @unique

    Lesson       Lesson       @relation(fields: [lessonId], references: [id])
    CoachPaySlip CoachPaySlip @relation(fields: [coachPayrollRecordId], references: [id])
}

model BillingBatch {
    id        String    @id @default(uuid())
    Invoices  Invoice[]
    createdOn DateTime  @default(now())
}

model SkaterLesson {
    Skater           Skater             @relation(fields: [skaterId], references: [id])
    skaterId         String
    Lesson           Lesson             @relation(fields: [lessonId], references: [id])
    lessonId         String
    InvoiceLineItems InvoiceLineItems[]

    @@id([skaterId, lessonId])
}

// Double Entry Bookkeeping 

enum TransactionType {
    Credit
    Debit
}

// Coach
// Skater
model AccountType {
    code String @id

    Account                Account[]
    AccountTransactionType AccountTransactionType[]
}

// Student Charge
// Student Payment
// Coach Charge
// Coach Pay
model AccountTransactionType {
    code            String          @id
    description     String
    type            TransactionType
    accountTypeCode String

    AccountType        AccountType          @relation(fields: [accountTypeCode], references: [code])
    AccountTransaction AccountTransaction[]
}

model Account {
    id              String @id @default(uuid())
    name            String
    accountTypeCode String

    AccountType        AccountType          @relation(fields: [accountTypeCode], references: [code])
    AccountTransaction AccountTransaction[]
    Skater             Skater?
    Coach              Coach?

    @@unique([name, accountTypeCode])
}

// maybe account transactions should have an associated ledger transaction. could be optional? TBD
model AccountTransaction {
    id                         String   @id @default(uuid())
    accountId                  String
    date                       DateTime
    amountInCents              Int
    accountTransactionTypeCode String
    ledgerTransactionId        String?  @unique

    LedgerTransaction LedgerTransaction? @relation(fields: [ledgerTransactionId], references: [id])

    Account                Account                @relation(fields: [accountId], references: [id])
    AccountTransactionType AccountTransactionType @relation(fields: [accountTransactionTypeCode], references: [code])
}

model LedgerType {
    code                    String          @id
    positiveTransactionType TransactionType
    Ledgers                 Ledger[]
}

model Ledger {
    code           String @id
    name           String
    ledgerTypeCode String

    LedgerType         LedgerType          @relation(fields: [ledgerTypeCode], references: [code])
    CreditTransactions LedgerTransaction[] @relation("CreditLedger")
    DebitTransactions  LedgerTransaction[] @relation("DebitLedger")
}

model LedgerTransaction {
    id               String   @id @default(uuid())
    CreditLedger     Ledger   @relation("CreditLedger", fields: [creditLedgerCode], references: [code])
    DebitLedger      Ledger   @relation("DebitLedger", fields: [debitLedgerCode], references: [code])
    creditLedgerCode String
    debitLedgerCode  String
    date             DateTime
    amountInCents    Int

    AccountTrasaction AccountTransaction?
}
